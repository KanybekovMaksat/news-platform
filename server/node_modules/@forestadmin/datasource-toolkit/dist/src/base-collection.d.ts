import { ActionField, ActionResult } from './interfaces/action';
import { Caller } from './interfaces/caller';
import { Chart } from './interfaces/chart';
import { Collection, DataSource } from './interfaces/collection';
import Aggregation, { AggregateResult } from './interfaces/query/aggregation';
import PaginatedFilter from './interfaces/query/filter/paginated';
import Filter from './interfaces/query/filter/unpaginated';
import Projection from './interfaces/query/projection';
import { RecordData } from './interfaces/record';
import { ActionSchema, CollectionSchema, FieldSchema } from './interfaces/schema';
export default abstract class BaseCollection implements Collection {
    readonly dataSource: DataSource;
    readonly name: string;
    readonly schema: CollectionSchema;
    constructor(name: string, datasource: DataSource);
    protected addAction(name: string, schema: ActionSchema): void;
    protected addChart(name: string): void;
    protected addField(name: string, schema: FieldSchema): void;
    protected addFields(fields: {
        [fieldName: string]: FieldSchema;
    }): void;
    protected addSegments(segments: string[]): void;
    protected enableCount(): void;
    protected enableSearch(): void;
    abstract create(caller: Caller, data: RecordData[]): Promise<RecordData[]>;
    abstract list(caller: Caller, filter: PaginatedFilter, projection: Projection): Promise<RecordData[]>;
    abstract update(caller: Caller, filter: Filter, patch: RecordData): Promise<void>;
    abstract delete(caller: Caller, filter: Filter): Promise<void>;
    abstract aggregate(caller: Caller, filter: Filter, aggregation: Aggregation, limit?: number): Promise<AggregateResult[]>;
    execute(caller: Caller, name: string): Promise<ActionResult>;
    getForm(): Promise<ActionField[]>;
    renderChart(caller: Caller, name: string): Promise<Chart>;
}
//# sourceMappingURL=base-collection.d.ts.map