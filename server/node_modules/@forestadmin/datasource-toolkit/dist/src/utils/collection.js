"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const schema_1 = __importDefault(require("./schema"));
const factory_1 = __importDefault(require("../interfaces/query/condition-tree/factory"));
const factory_2 = __importDefault(require("../interfaces/query/filter/factory"));
const unpaginated_1 = __importDefault(require("../interfaces/query/filter/unpaginated"));
const projection_1 = __importDefault(require("../interfaces/query/projection"));
class CollectionUtils {
    static getFieldSchema(collection, path) {
        const { fields } = collection.schema;
        const index = path.indexOf(':');
        if (index === -1) {
            if (!fields[path])
                throw new Error(`Column not found '${collection.name}.${path}'`);
            return fields[path];
        }
        const associationName = path.substring(0, index);
        const schema = fields[associationName];
        if (!schema) {
            throw new Error(`Relation not found '${collection.name}.${associationName}'`);
        }
        if (schema.type !== 'ManyToOne' && schema.type !== 'OneToOne') {
            throw new Error(`Unexpected field type '${schema.type}': '${collection.name}.${associationName}'`);
        }
        return CollectionUtils.getFieldSchema(collection.dataSource.getCollection(schema.foreignCollection), path.substring(index + 1));
    }
    static getInverseRelation(collection, relationName) {
        const relation = collection.schema.fields[relationName];
        const foreignCollection = collection.dataSource.getCollection(relation.foreignCollection);
        const inverse = Object.entries(foreignCollection.schema.fields).find(([, field]) => {
            const isManyToManyInverse = field.type === 'ManyToMany' &&
                relation.type === 'ManyToMany' &&
                field.originKey === relation.foreignKey &&
                field.throughCollection === relation.throughCollection &&
                field.foreignKey === relation.originKey;
            const isManyToOneInverse = field.type === 'ManyToOne' &&
                (relation.type === 'OneToMany' || relation.type === 'OneToOne') &&
                field.foreignKey === relation.originKey;
            const isOtherInverse = (field.type === 'OneToMany' || field.type === 'OneToOne') &&
                relation.type === 'ManyToOne' &&
                field.originKey === relation.foreignKey;
            return ((isManyToManyInverse || isManyToOneInverse || isOtherInverse) &&
                field.foreignCollection === collection.name);
        });
        return inverse ? inverse[0] : null;
    }
    static getThroughOrigin(collection, relationName) {
        const relation = collection.schema.fields[relationName];
        if (relation.type !== 'ManyToMany')
            throw new Error('Relation must be many to many');
        const throughCollection = collection.dataSource.getCollection(relation.throughCollection);
        const originRelation = Object.entries(throughCollection.schema.fields).find(([, field]) => {
            return (field.type === 'ManyToOne' &&
                field.foreignCollection === collection.name &&
                field.foreignKey === relation.originKey &&
                field.foreignKeyTarget === relation.originKeyTarget);
        });
        return originRelation ? originRelation[0] : null;
    }
    static getThroughTarget(collection, relationName) {
        const relation = collection.schema.fields[relationName];
        if (relation.type !== 'ManyToMany')
            throw new Error('Relation must be many to many');
        const throughCollection = collection.dataSource.getCollection(relation.throughCollection);
        const foreignRelation = Object.entries(throughCollection.schema.fields).find(([, field]) => {
            return (field.type === 'ManyToOne' &&
                field.foreignCollection === relation.foreignCollection &&
                field.foreignKey === relation.foreignKey &&
                field.foreignKeyTarget === relation.foreignKeyTarget);
        });
        return foreignRelation ? foreignRelation[0] : null;
    }
    static async listRelation(collection, id, relationName, caller, foreignFilter, projection) {
        const relation = schema_1.default.getToManyRelation(collection.schema, relationName);
        const foreign = collection.dataSource.getCollection(relation.foreignCollection);
        // Optimization for many to many when there is not search/segment.
        if (relation.type === 'ManyToMany' && foreignFilter.isNestable) {
            const foreignRelation = CollectionUtils.getThroughTarget(collection, relationName);
            if (foreignRelation) {
                const through = collection.dataSource.getCollection(relation.throughCollection);
                const records = await through.list(caller, await factory_2.default.makeThroughFilter(collection, id, relationName, caller, foreignFilter), projection.nest(foreignRelation));
                // Exclude null records, which may happen in case of a broken relation.
                // This happens on databases that don't support enforced foreign keys (e.g. Mongo)
                return records.map(r => r[foreignRelation]).filter(Boolean);
            }
        }
        // Otherwise fetch the target table (this works with both relation types)
        return foreign.list(caller, await factory_2.default.makeForeignFilter(collection, id, relationName, caller, foreignFilter), projection);
    }
    static async aggregateRelation(collection, id, relationName, caller, foreignFilter, aggregation, limit) {
        const relation = schema_1.default.getToManyRelation(collection.schema, relationName);
        const foreign = collection.dataSource.getCollection(relation.foreignCollection);
        // Optimization for many to many when there is not search/segment (saves one query)
        if (relation.type === 'ManyToMany' && foreignFilter.isNestable) {
            const foreignRelation = CollectionUtils.getThroughTarget(collection, relationName);
            if (foreignRelation) {
                const through = collection.dataSource.getCollection(relation.throughCollection);
                const records = await through.aggregate(caller, await factory_2.default.makeThroughFilter(collection, id, relationName, caller, foreignFilter), aggregation.nest(foreignRelation), limit);
                // unnest aggregation result
                return records.map(({ value, group }) => ({
                    value,
                    group: Object.entries(group)
                        .map(([key, v]) => [key.substring(key.indexOf(':') + 1), v])
                        .reduce((memo, [key, v]) => ({ ...memo, [key]: v }), {}),
                }));
            }
        }
        // Otherwise fetch the target table (this works with both relation types)
        return foreign.aggregate(caller, await factory_2.default.makeForeignFilter(collection, id, relationName, caller, foreignFilter), aggregation, limit);
    }
    static async getValue(collection, caller, id, field) {
        const index = schema_1.default.getPrimaryKeys(collection.schema).indexOf(field);
        if (index !== -1)
            return id[index];
        const [record] = await collection.list(caller, new unpaginated_1.default({ conditionTree: factory_1.default.matchIds(collection.schema, [id]) }), new projection_1.default(field));
        return record[field];
    }
}
exports.default = CollectionUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9jb2xsZWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsc0RBQW1DO0FBSW5DLHlGQUE4RTtBQUM5RSxpRkFBK0Q7QUFFL0QseUZBQTREO0FBQzVELGdGQUF3RDtBQUl4RCxNQUFxQixlQUFlO0lBQ2xDLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBc0IsRUFBRSxJQUFZO1FBQ3hELE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO1FBQ3JDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFaEMsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsVUFBVSxDQUFDLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBRXBGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3JCO1FBRUQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDakQsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBbUIsQ0FBQztRQUV6RCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsVUFBVSxDQUFDLElBQUksSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO1NBQy9FO1FBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtZQUM3RCxNQUFNLElBQUksS0FBSyxDQUNiLDBCQUEwQixNQUFNLENBQUMsSUFBSSxPQUFPLFVBQVUsQ0FBQyxJQUFJLElBQUksZUFBZSxHQUFHLENBQ2xGLENBQUM7U0FDSDtRQUVELE9BQU8sZUFBZSxDQUFDLGNBQWMsQ0FDbkMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQzdELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUMxQixDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFzQixFQUFFLFlBQW9CO1FBQ3BFLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBbUIsQ0FBQztRQUMxRSxNQUFNLGlCQUFpQixHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzFGLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FDbEUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUEyQixFQUFFLEVBQUU7WUFDdEMsTUFBTSxtQkFBbUIsR0FDdkIsS0FBSyxDQUFDLElBQUksS0FBSyxZQUFZO2dCQUMzQixRQUFRLENBQUMsSUFBSSxLQUFLLFlBQVk7Z0JBQzlCLEtBQUssQ0FBQyxTQUFTLEtBQUssUUFBUSxDQUFDLFVBQVU7Z0JBQ3ZDLEtBQUssQ0FBQyxpQkFBaUIsS0FBSyxRQUFRLENBQUMsaUJBQWlCO2dCQUN0RCxLQUFLLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFFMUMsTUFBTSxrQkFBa0IsR0FDdEIsS0FBSyxDQUFDLElBQUksS0FBSyxXQUFXO2dCQUMxQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssV0FBVyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDO2dCQUMvRCxLQUFLLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFFMUMsTUFBTSxjQUFjLEdBQ2xCLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxXQUFXLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUM7Z0JBQ3pELFFBQVEsQ0FBQyxJQUFJLEtBQUssV0FBVztnQkFDN0IsS0FBSyxDQUFDLFNBQVMsS0FBSyxRQUFRLENBQUMsVUFBVSxDQUFDO1lBRTFDLE9BQU8sQ0FDTCxDQUFDLG1CQUFtQixJQUFJLGtCQUFrQixJQUFJLGNBQWMsQ0FBQztnQkFDN0QsS0FBSyxDQUFDLGlCQUFpQixLQUFLLFVBQVUsQ0FBQyxJQUFJLENBQzVDLENBQUM7UUFDSixDQUFDLENBQzBCLENBQUM7UUFFOUIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsVUFBc0IsRUFBRSxZQUFvQjtRQUNsRSxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUN4RCxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssWUFBWTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUVyRixNQUFNLGlCQUFpQixHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzFGLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FDekUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUEyQixFQUFFLEVBQUU7WUFDdEMsT0FBTyxDQUNMLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVztnQkFDMUIsS0FBSyxDQUFDLGlCQUFpQixLQUFLLFVBQVUsQ0FBQyxJQUFJO2dCQUMzQyxLQUFLLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQyxTQUFTO2dCQUN2QyxLQUFLLENBQUMsZ0JBQWdCLEtBQUssUUFBUSxDQUFDLGVBQWUsQ0FDcEQsQ0FBQztRQUNKLENBQUMsQ0FDMEIsQ0FBQztRQUU5QixPQUFPLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDbkQsQ0FBQztJQUVELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFzQixFQUFFLFlBQW9CO1FBQ2xFLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3hELElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxZQUFZO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1FBRXJGLE1BQU0saUJBQWlCLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDMUYsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUMxRSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQTJCLEVBQUUsRUFBRTtZQUN0QyxPQUFPLENBQ0wsS0FBSyxDQUFDLElBQUksS0FBSyxXQUFXO2dCQUMxQixLQUFLLENBQUMsaUJBQWlCLEtBQUssUUFBUSxDQUFDLGlCQUFpQjtnQkFDdEQsS0FBSyxDQUFDLFVBQVUsS0FBSyxRQUFRLENBQUMsVUFBVTtnQkFDeEMsS0FBSyxDQUFDLGdCQUFnQixLQUFLLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FDckQsQ0FBQztRQUNKLENBQUMsQ0FDMEIsQ0FBQztRQUU5QixPQUFPLGVBQWUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDckQsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUN2QixVQUFzQixFQUN0QixFQUFlLEVBQ2YsWUFBb0IsRUFDcEIsTUFBYyxFQUNkLGFBQThCLEVBQzlCLFVBQXNCO1FBRXRCLE1BQU0sUUFBUSxHQUFHLGdCQUFXLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNoRixNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUVoRixrRUFBa0U7UUFDbEUsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFlBQVksSUFBSSxhQUFhLENBQUMsVUFBVSxFQUFFO1lBQzlELE1BQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFFbkYsSUFBSSxlQUFlLEVBQUU7Z0JBQ25CLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2dCQUNoRixNQUFNLE9BQU8sR0FBRyxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQ2hDLE1BQU0sRUFDTixNQUFNLGlCQUFhLENBQUMsaUJBQWlCLENBQ25DLFVBQVUsRUFDVixFQUFFLEVBQ0YsWUFBWSxFQUNaLE1BQU0sRUFDTixhQUFhLENBQ2QsRUFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUNqQyxDQUFDO2dCQUVGLHVFQUF1RTtnQkFDdkUsa0ZBQWtGO2dCQUNsRixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDM0U7U0FDRjtRQUVELHlFQUF5RTtRQUN6RSxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQ2pCLE1BQU0sRUFDTixNQUFNLGlCQUFhLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxFQUMxRixVQUFVLENBQ1gsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUM1QixVQUFzQixFQUN0QixFQUFlLEVBQ2YsWUFBb0IsRUFDcEIsTUFBYyxFQUNkLGFBQXFCLEVBQ3JCLFdBQXdCLEVBQ3hCLEtBQWM7UUFFZCxNQUFNLFFBQVEsR0FBRyxnQkFBVyxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDaEYsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFaEYsbUZBQW1GO1FBQ25GLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxZQUFZLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRTtZQUM5RCxNQUFNLGVBQWUsR0FBRyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRW5GLElBQUksZUFBZSxFQUFFO2dCQUNuQixNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQztnQkFDaEYsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsU0FBUyxDQUNyQyxNQUFNLEVBQ04sTUFBTSxpQkFBYSxDQUFDLGlCQUFpQixDQUNuQyxVQUFVLEVBQ1YsRUFBRSxFQUNGLFlBQVksRUFDWixNQUFNLEVBQ04sYUFBYSxDQUNkLEVBQ0QsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFDakMsS0FBSyxDQUNOLENBQUM7Z0JBRUYsNEJBQTRCO2dCQUM1QixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDeEMsS0FBSztvQkFDTCxLQUFLLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7eUJBQ3pCLEdBQUcsQ0FBb0IsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7eUJBQzlFLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7aUJBQzNELENBQUMsQ0FBQyxDQUFDO2FBQ0w7U0FDRjtRQUVELHlFQUF5RTtRQUN6RSxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQ3RCLE1BQU0sRUFDTixNQUFNLGlCQUFhLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxFQUMxRixXQUFXLEVBQ1gsS0FBSyxDQUNOLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQ25CLFVBQXNCLEVBQ3RCLE1BQWMsRUFDZCxFQUFlLEVBQ2YsS0FBYTtRQUViLE1BQU0sS0FBSyxHQUFHLGdCQUFXLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0UsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDO1lBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbkMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sVUFBVSxDQUFDLElBQUksQ0FDcEMsTUFBTSxFQUNOLElBQUkscUJBQU0sQ0FBQyxFQUFFLGFBQWEsRUFBRSxpQkFBb0IsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUNyRixJQUFJLG9CQUFVLENBQUMsS0FBSyxDQUFDLENBQ3RCLENBQUM7UUFFRixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDO0NBQ0Y7QUFsTkQsa0NBa05DIn0=