import PaginatedFilter from './paginated';
import Filter from './unpaginated';
import { Caller } from '../../caller';
import { Collection } from '../../collection';
import { CompositeId } from '../../record';
export default class FilterFactory {
    private static getPreviousConditionTree;
    private static getPreviousPeriodByUnit;
    static getPreviousPeriodFilter(filter: Filter, timezone: string): Filter;
    /**
     * Make a filter targeting the through collection of a many to many relationship from the relation
     * and a filter to the target collection.
     */
    static makeThroughFilter(collection: Collection, id: CompositeId, relationName: string, caller: Caller, baseForeignFilter: PaginatedFilter): Promise<PaginatedFilter>;
    /**
     * Given a collection and a OneToMany/ManyToMany relation, generate a filter which
     * - match only children of the provided recordId
     * - can apply on the target collection of the relation
     */
    static makeForeignFilter(collection: Collection, id: CompositeId, relationName: string, caller: Caller, baseForeignFilter: PaginatedFilter): Promise<Filter>;
}
//# sourceMappingURL=factory.d.ts.map