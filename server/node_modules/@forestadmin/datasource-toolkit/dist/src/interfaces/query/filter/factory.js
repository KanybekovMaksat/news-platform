"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const luxon_1 = require("luxon");
const unpaginated_1 = __importDefault(require("./unpaginated"));
const collection_1 = __importDefault(require("../../../utils/collection"));
const schema_1 = __importDefault(require("../../../utils/schema"));
const factory_1 = __importDefault(require("../condition-tree/factory"));
const leaf_1 = __importDefault(require("../condition-tree/nodes/leaf"));
const projection_1 = __importDefault(require("../projection"));
class FilterFactory {
    static getPreviousConditionTree(field, startPeriod, endPeriod) {
        return factory_1.default.intersect(new leaf_1.default(field, 'GreaterThan', startPeriod.toISO()), new leaf_1.default(field, 'LessThan', endPeriod.toISO()));
    }
    static getPreviousPeriodByUnit(field, now, interval) {
        const dayBeforeYesterday = now.minus({ [interval]: 2 });
        return this.getPreviousConditionTree(field, dayBeforeYesterday.startOf(interval), dayBeforeYesterday.endOf(interval));
    }
    static getPreviousPeriodFilter(filter, timezone) {
        const now = luxon_1.DateTime.now().setZone(timezone);
        return filter.override({
            conditionTree: filter.conditionTree.replaceLeafs(leaf => {
                switch (leaf.operator) {
                    case 'Today':
                        return leaf.override({ operator: 'Yesterday' });
                    case 'Yesterday':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'day');
                    case 'PreviousWeek':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'week');
                    case 'PreviousMonth':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'month');
                    case 'PreviousQuarter':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'quarter');
                    case 'PreviousYear':
                        return this.getPreviousPeriodByUnit(leaf.field, now, 'year');
                    case 'PreviousXDays': {
                        const startPeriodXDays = now.minus({ days: 2 * Number(leaf.value) });
                        const endPeriodXDays = now.minus({ days: Number(leaf.value) });
                        return this.getPreviousConditionTree(leaf.field, startPeriodXDays.startOf('day'), endPeriodXDays.startOf('day'));
                    }
                    case 'PreviousXDaysToDate': {
                        const startPeriod = now.minus({ days: 2 * Number(leaf.value) });
                        const endPeriod = now.minus({ days: Number(leaf.value) });
                        return this.getPreviousConditionTree(leaf.field, startPeriod.startOf('day'), endPeriod);
                    }
                    case 'PreviousWeekToDate':
                        return leaf.override({ operator: 'PreviousWeek' });
                    case 'PreviousMonthToDate':
                        return leaf.override({ operator: 'PreviousMonth' });
                    case 'PreviousQuarterToDate':
                        return leaf.override({ operator: 'PreviousQuarter' });
                    case 'PreviousYearToDate':
                        return leaf.override({ operator: 'PreviousYear' });
                    default:
                        return leaf;
                }
            }),
        });
    }
    /**
     * Make a filter targeting the through collection of a many to many relationship from the relation
     * and a filter to the target collection.
     */
    static async makeThroughFilter(collection, id, relationName, caller, baseForeignFilter) {
        const relation = collection.schema.fields[relationName];
        const originValue = await collection_1.default.getValue(collection, caller, id, relation.originKeyTarget);
        const foreignRelation = collection_1.default.getThroughTarget(collection, relationName);
        // Optimization for many to many when there is not search/segment (saves one query)
        if (foreignRelation && baseForeignFilter.isNestable) {
            const foreignKeySchema = collection.dataSource.getCollection(relation.throughCollection)
                .schema.fields[relation.foreignKey];
            const baseThroughFilter = baseForeignFilter.nest(foreignRelation);
            let conditionTree = factory_1.default.intersect(new leaf_1.default(relation.originKey, 'Equal', originValue), baseThroughFilter.conditionTree);
            if (foreignKeySchema.type === 'Column' && foreignKeySchema.filterOperators.has('Present')) {
                const present = new leaf_1.default(relation.foreignKey, 'Present');
                conditionTree = factory_1.default.intersect(conditionTree, present);
            }
            return baseThroughFilter.override({ conditionTree });
        }
        // Otherwise we have no choice but to call the target collection so that search and segment
        // are correctly apply, and then match ids in the though collection.
        const target = collection.dataSource.getCollection(relation.foreignCollection);
        const records = await target.list(caller, await FilterFactory.makeForeignFilter(collection, id, relationName, caller, baseForeignFilter), new projection_1.default(relation.foreignKeyTarget));
        return new unpaginated_1.default({
            conditionTree: factory_1.default.intersect(
            // only children of parent
            new leaf_1.default(relation.originKey, 'Equal', originValue), 
            // only the children which match the conditions in baseForeignFilter
            new leaf_1.default(relation.foreignKey, 'In', records.map(r => r[relation.foreignKeyTarget]))),
        });
    }
    /**
     * Given a collection and a OneToMany/ManyToMany relation, generate a filter which
     * - match only children of the provided recordId
     * - can apply on the target collection of the relation
     */
    static async makeForeignFilter(collection, id, relationName, caller, baseForeignFilter) {
        const relation = schema_1.default.getToManyRelation(collection.schema, relationName);
        const originValue = await collection_1.default.getValue(collection, caller, id, relation.originKeyTarget);
        // Compute condition tree to match parent record.
        let originTree;
        if (relation.type === 'OneToMany') {
            // OneToMany case (can be done in one request all the time)
            originTree = new leaf_1.default(relation.originKey, 'Equal', originValue);
        }
        else {
            // ManyToMany case (more complicated...)
            const through = collection.dataSource.getCollection(relation.throughCollection);
            const foreignKeySchema = through.schema.fields[relation.foreignKey];
            let throughTree = new leaf_1.default(relation.originKey, 'Equal', originValue);
            // Handle null foreign key case only when the datasource supports it.
            if (foreignKeySchema.type === 'Column' && foreignKeySchema.filterOperators.has('Present')) {
                throughTree = factory_1.default.intersect(throughTree, new leaf_1.default(relation.foreignKey, 'Present'));
            }
            const records = await through.list(caller, new unpaginated_1.default({ conditionTree: throughTree }), new projection_1.default(relation.foreignKey));
            originTree = new leaf_1.default(relation.foreignKeyTarget, 'In', 
            // filter out null values in case the 'Present' operator was not supported
            records.map(r => r[relation.foreignKey]).filter(v => v !== null));
        }
        // Merge with existing filter.
        return baseForeignFilter.override({
            conditionTree: factory_1.default.intersect(baseForeignFilter.conditionTree, originTree),
        });
    }
}
exports.default = FilterFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcmZhY2VzL3F1ZXJ5L2ZpbHRlci9mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQStDO0FBRy9DLGdFQUFtQztBQUNuQywyRUFBd0Q7QUFDeEQsbUVBQWdEO0FBS2hELHdFQUE2RDtBQUU3RCx3RUFBNkQ7QUFDN0QsK0RBQXVDO0FBRXZDLE1BQXFCLGFBQWE7SUFDeEIsTUFBTSxDQUFDLHdCQUF3QixDQUNyQyxLQUFhLEVBQ2IsV0FBcUIsRUFDckIsU0FBbUI7UUFFbkIsT0FBTyxpQkFBb0IsQ0FBQyxTQUFTLENBQ25DLElBQUksY0FBaUIsQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUNoRSxJQUFJLGNBQWlCLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FDNUQsQ0FBQztJQUNKLENBQUM7SUFFTyxNQUFNLENBQUMsdUJBQXVCLENBQ3BDLEtBQWEsRUFDYixHQUFhLEVBQ2IsUUFBZ0I7UUFFaEIsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUNsQyxLQUFLLEVBQ0wsa0JBQWtCLENBQUMsT0FBTyxDQUFDLFFBQXdCLENBQUMsRUFDcEQsa0JBQWtCLENBQUMsS0FBSyxDQUFDLFFBQXdCLENBQUMsQ0FDbkQsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsdUJBQXVCLENBQUMsTUFBYyxFQUFFLFFBQWdCO1FBQzdELE1BQU0sR0FBRyxHQUFHLGdCQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTdDLE9BQU8sTUFB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