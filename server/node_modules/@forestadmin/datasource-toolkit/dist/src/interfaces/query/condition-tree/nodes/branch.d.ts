import ConditionTree from './base';
import { AsyncLeafReplacer, LeafCallback, LeafReplacer, LeafTester, PlainConditionTreeLeaf } from './leaf';
import { Collection } from '../../../collection';
import { RecordData } from '../../../record';
import Projection from '../../projection';
export type Aggregator = 'And' | 'Or';
export type PlainConditionTreeBranch = {
    aggregator: Aggregator;
    conditions: Array<PlainConditionTreeBranch | PlainConditionTreeLeaf>;
};
export default class ConditionTreeBranch extends ConditionTree {
    aggregator: Aggregator;
    conditions: ConditionTree[];
    get projection(): Projection;
    constructor(aggregator: Aggregator, conditions: ConditionTree[]);
    forEachLeaf(handler: LeafCallback): void;
    everyLeaf(handler: LeafTester): boolean;
    someLeaf(handler: LeafTester): boolean;
    inverse(): ConditionTree;
    replaceLeafs(handler: LeafReplacer, bind?: unknown): ConditionTree;
    replaceLeafsAsync(handler: AsyncLeafReplacer, bind?: unknown): Promise<ConditionTree>;
    match(record: RecordData, collection: Collection, timezone: string): boolean;
}
//# sourceMappingURL=branch.d.ts.map