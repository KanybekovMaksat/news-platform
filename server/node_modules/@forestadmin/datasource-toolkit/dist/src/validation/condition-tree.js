"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const field_1 = __importDefault(require("./field"));
const rules_1 = require("./rules");
const errors_1 = require("../errors");
const branch_1 = __importDefault(require("../interfaces/query/condition-tree/nodes/branch"));
const leaf_1 = __importDefault(require("../interfaces/query/condition-tree/nodes/leaf"));
const collection_1 = __importDefault(require("../utils/collection"));
class ConditionTreeValidator {
    static validate(conditionTree, collection) {
        if (conditionTree instanceof branch_1.default) {
            ConditionTreeValidator.validateBranch(conditionTree, collection);
        }
        else if (conditionTree instanceof leaf_1.default) {
            ConditionTreeValidator.validateLeaf(conditionTree, collection);
        }
        else {
            throw new errors_1.ValidationError('Unexpected condition tree type');
        }
    }
    static validateBranch(branch, collection) {
        if (!['And', 'Or'].includes(branch.aggregator)) {
            throw new errors_1.ValidationError(`The given aggregator '${branch.aggregator}' ` +
                `is not supported. The supported values are: ['Or', 'And']`);
        }
        if (!Array.isArray(branch.conditions)) {
            throw new errors_1.ValidationError(`The given conditions '${branch.conditions}' were expected to be an array`);
        }
        for (const condition of branch.conditions) {
            ConditionTreeValidator.validate(condition, collection);
        }
    }
    static validateLeaf(leaf, collection) {
        const fieldSchema = collection_1.default.getFieldSchema(collection, leaf.field);
        ConditionTreeValidator.throwIfOperatorNotAllowedWithColumn(leaf, fieldSchema);
        ConditionTreeValidator.throwIfValueNotAllowedWithOperator(leaf, fieldSchema);
        ConditionTreeValidator.throwIfOperatorNotAllowedWithColumnType(leaf, fieldSchema);
        ConditionTreeValidator.throwIfValueNotAllowedWithColumnType(leaf, fieldSchema);
    }
    static throwIfOperatorNotAllowedWithColumn(conditionTree, columnSchema) {
        const operators = columnSchema.filterOperators;
        if (!operators?.has(conditionTree.operator)) {
            throw new errors_1.ValidationError(`The given operator '${conditionTree.operator}' ` +
                `is not supported by the column: '${conditionTree.field}'.\n${operators?.size
                    ? `The allowed types are: [${[...operators]}]`
                    : 'the column is not filterable'}`);
        }
    }
    static throwIfValueNotAllowedWithOperator(conditionTree, columnSchema) {
        const { value, field } = conditionTree;
        const allowedTypes = rules_1.MAP_ALLOWED_TYPES_FOR_OPERATOR_CONDITION_TREE[conditionTree.operator];
        this.validateValues(field, columnSchema, value, allowedTypes);
    }
    static throwIfOperatorNotAllowedWithColumnType(conditionTree, columnSchema) {
        const allowedOperators = rules_1.MAP_ALLOWED_OPERATORS_FOR_COLUMN_TYPE[columnSchema.columnType];
        if (!allowedOperators.includes(conditionTree.operator)) {
            throw new errors_1.ValidationError(`The given operator '${conditionTree.operator}' ` +
                `is not allowed with the columnType schema: '${columnSchema.columnType}'.\n` +
                `The allowed types are: [${allowedOperators}]`);
        }
    }
    static throwIfValueNotAllowedWithColumnType(conditionTree, columnSchema) {
        const { value, field, operator } = conditionTree;
        // exclude some cases where the value is not related to the columnType of the field
        if (operator !== 'ShorterThan' &&
            operator !== 'LongerThan' &&
            operator !== 'AfterXHoursAgo' &&
            operator !== 'BeforeXHoursAgo' &&
            operator !== 'PreviousXDays' &&
            operator !== 'PreviousXDaysToDate') {
            const types = rules_1.MAP_ALLOWED_TYPES_FOR_COLUMN_TYPE[columnSchema.columnType];
            this.validateValues(field, columnSchema, value, types);
        }
    }
    static validateValues(field, columnSchema, value, allowedTypes) {
        if (Array.isArray(value)) {
            value.forEach(itemValue => field_1.default.validateValue(field, columnSchema, itemValue, allowedTypes));
        }
        else {
            field_1.default.validateValue(field, columnSchema, value, allowedTypes);
        }
    }
}
exports.default = ConditionTreeValidator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZGl0aW9uLXRyZWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdmFsaWRhdGlvbi9jb25kaXRpb24tdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9EQUFxQztBQUNyQyxtQ0FJaUI7QUFDakIsc0NBQTRDO0FBRzVDLDZGQUFrRjtBQUNsRix5RkFBOEU7QUFFOUUscUVBQWtEO0FBRWxELE1BQXFCLHNCQUFzQjtJQUN6QyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQTRCLEVBQUUsVUFBc0I7UUFDbEUsSUFBSSxhQUFhLFlBQVksZ0JBQW1CLEVBQUU7WUFDaEQsc0JBQXNCLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUNsRTthQUFNLElBQUksYUFBYSxZQUFZLGNBQWlCLEVBQUU7WUFDckQsc0JBQXNCLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUNoRTthQUFNO1lBQ0wsTUFBTSxJQUFJLHdCQUFlLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFTyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQTJCLEVBQUUsVUFBc0I7UUFDL0UsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDOUMsTUFBTSxJQUFJLHdCQUFlLENBQ3ZCLHlCQUF5QixNQUFNLENBQUMsVUFBVSxJQUFJO2dCQUM1QywyREFBMkQsQ0FDOUQsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3JDLE1BQU0sSUFBSSx3QkFBZSxDQUN2Qix5QkFBeUIsTUFBTSxDQUFDLFVBQVUsZ0NBQWdDLENBQzNFLENBQUM7U0FDSDtRQUVELEtBQUssTUFBTSxTQUFTLElBQUksTUFBTSxDQUFD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