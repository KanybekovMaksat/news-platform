"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const schema_1 = __importDefault(require("../../mongoose/schema"));
const helpers_1 = require("../helpers");
/** Generate all relations which are not explicitly written in the mongoose schema using `ref` */
class RelationGenerator {
    /**
     * Scan collections for many to one relations, and inject all the other relations in the schemas
     * (one to one, one to many, many to many)
     */
    static addImplicitRelations(collections) {
        for (const collection of collections) {
            // Get many to one relations
            const manyToOnes = Object.entries(collection.schema.fields).filter(([, f]) => f.type === 'ManyToOne');
            // Create many to many (5 fields == _id + 2 relations + 2 foreignKeys)
            // @fixme this may break, we should check in the schema, but it's more complicated
            const isVirtualJunction = collection.name.includes('_') &&
                manyToOnes.length === 2 &&
                Object.keys(collection.schema.fields).length === 5;
            // Create relationships
            if (isVirtualJunction) {
                this.addManyToMany(collection, manyToOnes[0][1], manyToOnes[1][1]);
                this.addManyToMany(collection, manyToOnes[1][1], manyToOnes[0][1]);
            }
            else {
                for (const [name, field] of manyToOnes) {
                    this.addManyToOneInverse(collection, name, field);
                }
            }
        }
    }
    /**
     * Given any many to one relation, generated while parsing mongoose schema, generate the
     * inverse relationship on the foreignCollection.
     *
     * /!\ The inverse can be a OneToOne, or a ManyToOne
     */
    static addManyToOneInverse(collection, name, schema) {
        let type;
        let inverseName;
        if (name === 'parent') {
            // Create inverse of 'parent' relationship so that the relation name matches the actual name
            // of the data which is stored in the database.
            const { stack } = collection;
            const { prefix } = stack[stack.length - 1];
            const { isArray } = schema_1.default.fromModel(collection.model).applyStack(stack);
            type = isArray ? 'OneToMany' : 'OneToOne';
            inverseName = (0, helpers_1.escape)(prefix);
            if (stack.length > 2) {
                const previousLength = stack[stack.length - 2].prefix.length + 1;
                inverseName = prefix.substring(previousLength);
            }
        }
        else {
            // Native ManyToOne relationship (there is an actual foreign key in the document, this is
            // not an embedded document that we're faking as a relation).
            inverseName = (0, helpers_1.escape)(`${collection.name}_${name}__inverse`);
            type = 'OneToMany';
        }
        const otherCollection = collection.dataSource.getCollection(schema.foreignCollection);
        otherCollection.schema.fields[inverseName] = {
            type,
            foreignCollection: collection.name,
            originKey: schema.foreignKey,
            originKeyTarget: schema.foreignKeyTarget,
        };
    }
    /** Generate many to many from two many to one */
    static addManyToMany(throughCollection, originRelation, foreignRelation) {
        const origin = throughCollection.dataSource.getCollection(originRelation.foreignCollection);
        const relationName = (0, helpers_1.escape)(`${foreignRelation.foreignCollection}_through_${throughCollection.name}`);
        origin.schema.fields[relationName] = {
            type: 'ManyToMany',
            throughCollection: throughCollection.name,
            foreignCollection: foreignRelation.foreignCollection,
            foreignKey: foreignRelation.foreignKey,
            foreignKeyTarget: foreignRelation.foreignKeyTarget,
            originKey: originRelation.foreignKey,
            originKeyTarget: originRelation.foreignKeyTarget,
        };
    }
}
exports.default = RelationGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVsYXRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3V0aWxzL3NjaGVtYS9yZWxhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFHQSxtRUFBbUQ7QUFDbkQsd0NBQW9DO0FBRXBDLGlHQUFpRztBQUNqRyxNQUFxQixpQkFBaUI7SUFDcEM7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLG9CQUFvQixDQUFDLFdBQWlDO1FBQzNELEtBQUssTUFBTSxVQUFVLElBQUksV0FBVyxFQUFFO1lBQ3BDLDRCQUE0QjtZQUM1QixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUNoRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxXQUFXLENBQ0gsQ0FBQztZQUVqQyxzRUFBc0U7WUFDdEUsa0ZBQWtGO1lBQ2xGLE1BQU0saUJBQWlCLEdBQ3JCLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztnQkFDN0IsVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDO2dCQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztZQUVyRCx1QkFBdUI7WUFDdkIsSUFBSSxpQkFBaUIsRUFBRTtnQkFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMs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