"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unnest = exports.unflattenRecord = exports.buildSubdocumentPatch = exports.replaceMongoTypes = exports.groupIdsByPath = exports.splitId = exports.compareIds = exports.recursiveDelete = exports.recursiveSet = exports.escape = void 0;
const mongoose_1 = require("mongoose");
/**
 * Replace dots by underscores.
 *
 * @example
 * escape('a.b') == 'a_b'
 */
function escape(str) {
    return str.replace(/\./g, '_');
}
exports.escape = escape;
/**
 * Set a value in a plain object recursively
 *
 * @example
 * const a = {};
 * recursiveSet(a, 'field.subfield', 42);
 * a == { field: { subfield: 42 } }
 */
function recursiveSet(target, path, value) {
    const index = path.indexOf('.');
    if (index !== -1) {
        const prefix = path.substring(0, index);
        const suffix = path.substring(index + 1);
        target[prefix] ?? (target[prefix] = {});
        recursiveSet(target[prefix], suffix, value);
    }
    else {
        target[path] = value;
    }
}
exports.recursiveSet = recursiveSet;
/**
 * Remove a value in a plain object recursively
 * If the value is an object and is empty, it will be removed.
 *
 * @example
 * const a = { field: { subfield: 42 } };
 * recursiveDelete(a, 'field.subfield');
 * a == {  }
 */
function recursiveDelete(target, path) {
    const index = path.indexOf('.');
    if (index !== -1) {
        const prefix = path.substring(0, index);
        const suffix = path.substring(index + 1);
        recursiveDelete(target[prefix], suffix);
        if (Object.keys(target[prefix]).length === 0) {
            delete target[prefix];
        }
    }
    else {
        delete target[path];
    }
}
exports.recursiveDelete = recursiveDelete;
/**
 * Compare two ids.
 * This is useful to ensure we perform array operations in the right order.
 *
 * @example
 * compareIds('a.20.a', 'a.1.b') => 1 (because 1 < 20)
 * compareIds('a.0.a', 'b.1.b') => -1 (because 'a' < 'b')
 */
function compareIds(a, b) {
    const isNumber = /^\d+$/;
    const partsA = a.split('.');
    const partsB = b.split('.');
    const length = a.length < b.length ? a.length : b.length;
    for (let i = 0; i < length; i += 1) {
        if (partsA[i] !== partsB[i] && isNumber.test(partsA[i]) && isNumber.test(partsB[i]))
            return Number(partsA[i]) - Number(partsB[i]);
        if (partsA[i] < partsB[i])
            return -1;
        if (partsA[i] > partsB[i])
            return 1;
    }
    if (partsA.length < partsB.length)
        return -1;
    if (partsA.length > partsB.length)
        return 1;
    return 0;
}
exports.compareIds = compareIds;
/**
 * Split the fake ids which are generated when using the `asModel` option into rootId + path.
 *
 * @example
 * splitId('123.some.path.0.to.the.item) == [123, 'some.path.0.to.the.item]
 */
function splitId(id) {
    const dotIndex = id.indexOf('.');
    const rootId = id.substring(0, dotIndex);
    const path = id.substring(dotIndex + 1);
    // @fixme hack, we should never do that without looking at the schema
    return (0, mongoose_1.isValidObjectId)(rootId)
        ? [mongoose_1.Types.ObjectId.createFromHexString(rootId), path]
        : [rootId, path];
}
exports.splitId = splitId;
/**
 * Group the fake ids which are generated when using the `asModel` option by the path they are
 * targeting to help performing requests.
 *
 * @example
 * groupIdsByPath(['123.field', '456.field']) == { field: [123, 456] }
 */
function groupIdsByPath(ids) {
    const updates = {};
    for (const id of ids) {
        const [rootId, path] = splitId(id);
        updates[path] ?? (updates[path] = []);
        updates[path].push(rootId);
    }
    return updates;
}
exports.groupIdsByPath = groupIdsByPath;
/**
 * Replace ObjectId and Date instances in records by strings.
 *
 * @example
 * replaceMongoTypes({_id: ObjectId('12312321313'), createdAt: Date() })
 * == { _id: '12312321313', createdAt: '2010-01-01T00:00:00Z' }
 */
function replaceMongoTypes(records) {
    return JSON.parse(JSON.stringify(records));
}
exports.replaceMongoTypes = replaceMongoTypes;
/**
 * Takes a patch that was built to be applied on a subdocument, and returns a patch that can be
 * applied on the parent document.
 *
 * @example
 * nestPatch('authors.1', { _id: '123', name: 'Asimov'}, false)
 *  == nestPatch('authors.1.name', { _id: '123', content: 'Asimov'}, true)
 *  == { 'authors.1.name': 'Asimov' }
 */
function buildSubdocumentPatch(path, patch, isLeaf) {
    const cleanPatch = {};
    if (isLeaf) {
        cleanPatch[path] = patch.content;
    }
    else {
        for (const [key, value] of Object.entries(patch)) {
            if (key !== '_id' && key !== 'parentId') {
                cleanPatch[`${path}.${key}`] = value;
            }
        }
    }
    return cleanPatch;
}
exports.buildSubdocumentPatch = buildSubdocumentPatch;
/**
 * Unflattend patches and records
 */
function unflattenRecord(record, asFields, patchMode = false) {
    const newRecord = { ...record };
    for (const field of asFields) {
        const alias = field.replace(/\./g, '@@@');
        const value = newRecord[alias];
        if (value !== undefined) {
            if (patchMode)
                newRecord[field] = value;
            else
                recursiveSet(newRecord, field, value);
            delete newRecord[alias];
        }
    }
    return newRecord;
}
exports.unflattenRecord = unflattenRecord;
/**
 * Similar to projection.unnest
 * @example
 * unnest(['firstname', 'book.title', 'book.author'], 'book') == ['title', 'author']
 */
function unnest(strings, prefix) {
    return strings.filter(f => f.startsWith(`${prefix}.`)).map(f => f.substring(prefix.length + 1));
}
exports.unnest = unnest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLHVDQUFrRDtBQUVsRDs7Ozs7R0FLRztBQUNILFNBQWdCLE1BQU0sQ0FBQyxHQUFXO0lBQ2hDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUZELHdCQUVDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLFlBQVksQ0FBQyxNQUFXLEVBQUUsSUFBWSxFQUFFLEtBQWM7SUFDcEUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVoQyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNoQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN4QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN6QyxNQUFNLENBQUMsTUFBTSxNQUFiLE1BQU0sQ0FBQyxNQUFNLElBQU0sRUFBRSxFQUFDO1FBRXRCLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzdDO1NBQU07UUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ3RCO0FBQ0gsQ0FBQztBQVpELG9DQVlDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixlQUFlLENBQUMsTUFBVyxFQUFFLElBQVk7SUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVoQyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNoQixNQUFNLE1BQU0sR0FBRyxJ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