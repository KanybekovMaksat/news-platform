"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
const mongoose_1 = require("mongoose");
const helpers_1 = require("../utils/helpers");
class MongooseSchema {
    static fromModel(model) {
        return new MongooseSchema(model.db.models, this.buildFields(model.schema), false, false);
    }
    get schemaNode() {
        return this.isLeaf ? this.fields.content : this.fields;
    }
    get schemaType() {
        if (this.isLeaf) {
            return this.fields.content;
        }
        throw new Error(`Schema is not a leaf.`);
    }
    constructor(models, fields, isArray, isLeaf) {
        this.models = models;
        this.fields = fields;
        this.isArray = isArray;
        this.isLeaf = isLeaf;
    }
    listPathsMatching(handle, prefix) {
        if (this.isLeaf)
            return [];
        return Object.keys(this.fields).flatMap(field => {
            const schema = this.getSubSchema(field);
            const subPrefix = `${prefix ? `${prefix}.` : ''}${field}`;
            const subFields = schema
                .listPathsMatching(handle, subPrefix)
                .map(subField => `${field}.${subField}`);
            return handle(subPrefix, schema) ? [field, ...subFields] : subFields;
        });
    }
    /**
     * List leafs and arrays up to a certain level
     * Arrays are never traversed
     */
    listFields(level = Infinity) {
        if (this.isLeaf)
            throw new Error('Cannot list fields on a leaf schema.');
        if (level === 0)
            throw new Error('Level must be greater than 0.');
        if (level === 1)
            return Object.keys(this.fields);
        return Object.keys(this.fields).flatMap(field => {
            const schema = this.getSubSchema(field);
            if (schema.isLeaf || schema.isArray)
                return [field];
            return schema.listFields(level - 1).map(subField => `${field}.${subField}`);
        });
    }
    applyStack(stack, skipAsModels = false) {
        if (stack.length === 0)
            throw new Error('Stack can never be empty.');
        const step = stack.pop();
        const subSchema = this.getSubSchema(step.prefix);
        for (const field of step.asFields) {
            const fieldSchema = subSchema.getSubSchema(field);
            (0, helpers_1.recursiveDelete)(subSchema.fields, field);
            subSchema.fields[field.replace(/\./g, '@@@')] = fieldSchema.isArray
                ? { '[]': fieldSchema.schemaNode }
                : fieldSchema.schemaNode;
        }
        if (stack.length) {
            subSchema.fields._id = new mongoose_1.Schema.Types.String('__placeholder__');
            subSchema.fields.parent = this.applyStack(stack).fields;
            subSchema.fields.parentId = subSchema.fields.parent._id;
        }
        if (!skipAsModels) {
            for (const field of step.asModels) {
                (0, helpers_1.recursiveDelete)(this.fields, field);
            }
        }
        else {
            // Here we actually should recurse into the subSchema and add the _id and parentId fields
            // to the virtual one-to-one relations.
            //
            // The issue is that we can't do that because we don't know where the relations are after
            // the first level of nesting (we would need to have the complete asModel / asFields like in
            // the datasource.ts file).
            //
            // Because of that, we need to work around the missing fields in:
            // - pipeline/virtual-fields.ts file: we're throwing an error when we can't guess the value
            //   of a given _id / parentId field.
            // - pipeline/filter.ts: we're using an educated guess for the types of the _id / parentId
            //   fields (String or ObjectId)
        }
        stack.push(step);
        return subSchema;
    }
    getSubSchema(path) {
        // Terminating condition
        if (!path)
            return this;
        // General case: go down the tree
        const [prefix, suffix] = path.split(/\.(.*)/);
        let isArray = false;
        let isLeaf = false;
        let child = this.fields[prefix];
        // Traverse relations
        if (prefix.endsWith('__manyToOne')) {
            const foreignKeyName = prefix.substring(0, prefix.length - '__manyToOne'.length);
            const relationName = this.fields[foreignKeyName].options.ref;
            // FIXME We should definitively apply the foreign collection stack here
            child = MongooseSchema.fromModel(this.models[relationName]).fields;
        }
        else if (!child) {
            throw new Error(`Field '${prefix}' not found. Available fields are: ${this.listFields()}`);
        }
        // Traverse arrays
        if (child['[]']) {
            child = child['[]'];
            isArray = true;
        }
        // We ended up on a field => box it.
        if (child instanceof mongoose_1.SchemaType) {
            child = { content: child };
            isLeaf = true;
        }
        return new MongooseSchema(this.models, child, isArray, isLeaf).getSubSchema(suffix);
    }
    /**
     * Build a tree of SchemaType from a mongoose schema.
     * This removes most complexity from using prefixes, nested schemas and array types
     */
    static buildFields(schema, level = 0) {
        const paths = {};
        for (const [name, field] of Object.entries(schema.paths)) {
            // Exclude mixedFieldPattern $* and privateFieldPattern __
            if (!name.startsWith('$*') && !name.includes('__') && (name !== '_id' || level === 0)) {
                // Flatten nested schemas and arrays
                if (field.constructor.name === 'SubdocumentPath') {
                    const subPaths = this.buildFields(field.schema, level + 1);
                    for (const [subName, subField] of Object.entries(subPaths))
                        (0, helpers_1.recursiveSet)(paths, `${name}.${subName}`, subField);
                }
                else if (field.constructor.name === 'DocumentArrayPath') {
                    const subPaths = this.buildFields(field.schema, level + 1);
                    for (const [subName, subField] of Object.entries(subPaths))
                        (0, helpers_1.recursiveSet)(paths, `${name}.[].${subName}`, subField);
                }
                else if (field.constructor.name === 'SchemaArray') {
                    (0, helpers_1.recursiveSet)(paths, `${name}.[]`, field.caster);
                }
                else {
                    (0, helpers_1.recursiveSet)(paths, name, field);
                }
            }
        }
        return paths;
    }
}
exports.default = MongooseSchema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vbmdvb3NlL3NjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUF5QztBQUN6Qyx1REFBdUQ7QUFDdkQsdUNBQXFEO0FBR3JELDhDQUFpRTtBQUtqRSxNQUFxQixjQUFjO0lBT2pDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBcUI7UUFDcEMsT0FBTyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDM0YsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDekQsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFxQixDQUFDO1NBQzFDO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxZQUNFLE1BQXNDLEVBQ3RDLE1BQW9CLEVBQ3BCLE9BQWdCLEVBQ2hCLE1BQWU7UUFFZixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBRUQsaUJBQWlCLENBQ2YsTUFBMEQsRUFDMUQsTUFBZTtRQUVmLElBQUksSUFBSSxDQUFDLE1BQU07WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUUzQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM5QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sU0FBUyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUM7WUFDMUQsTUFBTSxTQUFTLEdBQUcsTUFBTTtpQkFDckIsaUJBQWlCLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQztpQkFDcEMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQztZQUUzQyxPQUFPLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUN2RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsS0FBSyxHQUFHLFFBQVE7UUFDekIsSUFBSSxJQUFJLENBQUMsTUFBTTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztRQUN6RSxJQUFJLEtBQUssS0FBSyxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1FBQ2xFLElBQUksS0FBSyxLQUFLLENBQUM7WUFBRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWpELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzlDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDeEMsSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPO2dCQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUVwRCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDOUUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQVksRUFBRSxZQUFZLEdBQUcsS0FBSztRQUMzQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztRQUVyRSxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDekIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFakQsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pDLE1BQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbEQsSUFBQSx5QkFBZSxFQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxPQUFPO2dCQUNqRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFVBQVUsRUFBRTtnQkFDbEMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7U0FDNUI7UUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDaEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxpQkFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUNsRSxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUN4RCxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7U0FDekQ7UUFFRCxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakMsSUFBQSx5QkFBZSxFQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDckM7U0FDRjthQUFNO1lBQ0wseUZBQXlGO1lBQ3pGLHVDQUF1QztZQUN2QyxFQUFFO1lBQ0YseUZBQXlGO1lBQ3pGLDRGQUE0RjtZQUM1RiwyQkFBMkI7WUFDM0IsRUFBRTtZQUNGLGlFQUFpRTtZQUNqRSwyRkFBMkY7WUFDM0YscUNBQXFDO1lBQ3JDLDBGQUEwRjtZQUMxRixnQ0FBZ0M7U0FDakM7UUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWpCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxZQUFZLENBQUMsSUFBWTtRQUN2Qix3QkFBd0I7UUFDeEIsSUFBSSxDQUFDLElBQUk7WUFBRSxPQUFPLElBQUksQ0FBQztRQUV2QixpQ0FBaUM7UUFDakMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlDLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQWlCLENBQUM7UUFFaEQscUJBQXFCO1FBQ3JCLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNsQyxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqRixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7WUFFN0QsdUVBQXVFO1lBQ3ZFLEtBQUssR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7U0FDcEU7YUFBTSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxNQUFNLHNDQUFzQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzVGO1FBRUQsa0JBQWtCO1FBQ2xCLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2YsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQWlCLENBQUM7WUFDcEMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUNoQjtRQUVELG9DQUFvQztRQUNwQyxJQUFJLEtBQUssWUFBWSxxQkFBVSxFQUFFO1lBQy9CLEtBQUssR0FBRyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUMzQixNQUFNLEdBQUcsSUFBSSxDQUFDO1NBQ2Y7UUFFRCxPQUFPLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUVEOzs7T0FHRztJQUNLLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBYyxFQUFFLEtBQUssR0FBRyxDQUFDO1FBQ2xELE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUVqQixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDeEQsMERBQTBEO1lBQzFELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUNyRixvQ0FBb0M7Z0JBQ3BDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLEVBQUU7b0JBQ2hELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQWdCLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNyRSxLQUFLLE1BQU0sQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7d0JBQ3hELElBQUEsc0JBQVksRUFBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLElBQUksT0FBTyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7aUJBQ3ZEO3FCQUFNLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLEVBQUU7b0JBQ3pELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQWdCLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNyRSxLQUFLLE1BQU0sQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7d0JBQ3hELElBQUEsc0JBQVksRUFBQyxLQUFLLEVBQUUsR0FBRyxJQUFJLE9BQU8sT0FBTyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7aUJBQzFEO3FCQUFNLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO29CQUNuRCxJQUFBLHNCQUFZLEVBQUMsS0FBSyxFQUFFLEdBQUcsSUFBSSxLQUFLLEVBQUcsS0FBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUMxRDtxQkFBTTtvQkFDTCxJQUFBLHNCQUFZLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDbEM7YUFDRjtTQUNGO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFsTEQsaUNBa0xDIn0=