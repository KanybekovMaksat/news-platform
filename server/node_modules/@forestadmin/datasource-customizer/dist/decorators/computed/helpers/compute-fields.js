"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const deduplication_1 = __importDefault(require("../utils/deduplication"));
const flattener_1 = require("../utils/flattener");
async function computeField(ctx, computed, paths, promises) {
    return (0, deduplication_1.default)((0, flattener_1.unflatten)(await Promise.all(promises), paths), 
    // Customer can return the following:
    // - an array of values [value, value, ...]
    // - an array of promises: [Promise<value>, Promise<value>, ...]
    // - a promise of an array of values: Promise<[value, value, ...]>
    // - a promise of an array of promises: Promise<[Promise<value>, Promise<value>, ...]>
    async (uniquePartials) => Promise.all(await computed.getValues(uniquePartials, ctx)));
}
function queueField(ctx, collection, newPath, paths, promises) {
    // Skip double computations (we're not checking before adding to queue).
    if (!paths.includes(newPath)) {
        const computed = collection.getComputed(newPath);
        const computedDependencies = (0, flattener_1.withNullMarkers)(computed.dependencies);
        const nestedDependencies = new datasource_toolkit_1.Projection(...computedDependencies).nest(newPath.includes(':') ? newPath.substring(0, newPath.lastIndexOf(':')) : null);
        // Queue dependencies (so that computed can await them).
        nestedDependencies.forEach(path => queueField(ctx, collection, path, paths, promises));
        // Queue computed
        const dependencyValues = nestedDependencies.map(path => promises[paths.indexOf(path)]);
        paths.push(newPath);
        promises.push(computeField(ctx, computed, computedDependencies, dependencyValues));
    }
}
async function computeFromRecords(ctx, collection, recordsProjection, desiredProjection, records) {
    // Format data for easy computation (one cell per path, with all values).
    const paths = (0, flattener_1.withNullMarkers)(recordsProjection);
    const promises = (0, flattener_1.flatten)(records, paths).map(values => Promise.resolve(values));
    // Queue all computations, and perform them all at once
    desiredProjection.forEach(path => queueField(ctx, collection, path, paths, promises));
    const values = await Promise.all(promises);
    // Quick reproject and unflatten.
    const finalProjection = (0, flattener_1.withNullMarkers)(desiredProjection);
    return (0, flattener_1.unflatten)(finalProjection.map(path => values[paths.indexOf(path)]), finalProjection);
}
exports.default = computeFromRecords;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcHV0ZS1maWVsZHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZGVjb3JhdG9ycy9jb21wdXRlZC9oZWxwZXJzL2NvbXB1dGUtZmllbGRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsd0VBQXlFO0FBS3pFLDJFQUEyRDtBQUMzRCxrREFBeUU7QUFFekUsS0FBSyxVQUFVLFlBQVksQ0FDekIsR0FBbUMsRUFDbkMsUUFBNEIsRUFDNUIsS0FBZSxFQUNmLFFBQThCO0lBRTlCLE9BQU8sSUFBQSx1QkFBcUIsRUFDMUIsSUFBQSxxQkFBUyxFQUFDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxLQUFLLENBQUM7SUFFN0MscUNBQXFDO0lBQ3JDLDJDQUEyQztJQUMzQyxnRUFBZ0U7SUFDaEUsa0VBQWtFO0lBQ2xFLHNGQUFzRjtJQUN0RixLQUFLLEVBQUMsY0FBYyxFQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FDbkYsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FDakIsR0FBbUMsRUFDbkMsVUFBOEIsRUFDOUIsT0FBZSxFQUNmLEtBQWUsRUFDZixRQUE4QjtJQUU5Qix3RUFBd0U7SUFDeEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDNUIsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNqRCxNQUFNLG9CQUFvQixHQUFHLElBQUEsMkJBQWUsRUFBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEUsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLCtCQUFVLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxDQUFDLElBQUksQ0FDckUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQzlFLENBQUM7UUFFRix3REFBd0Q7UUFDeEQsa0JBQWtCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBRXZGLGlCQUFpQjtRQUNqQixNQUFNLGdCQUFnQixHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2RixLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BCLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO0tBQ3BGO0FBQ0gsQ0FBQztBQUVjLEtBQUssVUFBVSxrQkFBa0IsQ0FDOUMsR0FBbUMsRUFDbkMsVUFBOEIsRUFDOUIsaUJBQTZCLEVBQzdCLGlCQUE2QixFQUM3QixPQUFxQjtJQUVyQix5RUFBeUU7SUFDekUsTUFBTSxLQUFLLEdBQUcsSUFBQSwyQkFBZSxFQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDakQsTUFBTSxRQUFRLEdBQUcsSUFBQSxtQkFBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFFaEYsdURBQXVEO0lBQ3ZELGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUN0RixNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFM0MsaUNBQWlDO0lBQ2pDLE1BQU0sZUFBZSxHQUFHLElBQUEsMkJBQWUsRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRTNELE9BQU8sSUFBQSxxQkFBUyxFQUNkLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ3hELGVBQWUsQ0FDaEIsQ0FBQztBQUNKLENBQUM7QUF0QkQscUNBc0JDIn0=