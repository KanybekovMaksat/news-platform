import { CollectionSchema, Operator } from '@forestadmin/datasource-toolkit';
import DataSourceCustomizer from './datasource-customizer';
import { ActionDefinition } from './decorators/actions/types/actions';
import { CollectionChartDefinition } from './decorators/chart/types';
import { ComputedDefinition } from './decorators/computed/types';
import DecoratorsStack from './decorators/decorators-stack';
import { HookHandler, HookPosition, HookType, HooksContext } from './decorators/hook/types';
import { OperatorDefinition } from './decorators/operators-emulate/types';
import { SearchDefinition } from './decorators/search/types';
import { SegmentDefinition } from './decorators/segment/types';
import { WriteDefinition } from './decorators/write/write-replace/types';
import { TCollectionName, TColumnName, TFieldName, TSchema, TSortClause } from './templates';
import { OneToManyEmbeddedDefinition, Plugin } from './types';
export default class CollectionCustomizer<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> {
    private readonly dataSourceCustomizer;
    private readonly stack;
    readonly name: string;
    get schema(): CollectionSchema;
    constructor(dataSourceCustomizer: DataSourceCustomizer<S>, stack: DecoratorsStack, name: string);
    /**
     * Load a plugin on the collection.
     * @param plugin reference to the plugin function
     * @param options options to pass to the plugin
     * @example
     * import { createFileField } from '@forestadmin/plugin-s3';
     *
     * collection.use(createFileField, { fieldname: 'avatar' }),
     */
    use<Options>(plugin: Plugin<Options>, options?: Options): this;
    /**
     * Disable count in list view pagination for improved performance.
     *
     * @example
     * .disableCount()
     */
    disableCount(): this;
    /**
     * Import a field from a many to one or one to one relation.
     *
     * @param name the name of the field that will be created on the collection
     * @param options options to import the field
     * @example
     * .importField('authorName', { path: 'author:fullName' })
     */
    importField(name: string, options: {
        path: TFieldName<S, N>;
        readonly?: boolean;
    }): this;
    /**
     * Allow to rename a field of a given collection.
     * @param oldName the current name of the field in a given collection
     * @param newName the new name of the field
     * @example
     * .renameField('theCurrentNameOfTheField', 'theNewNameOfTheField');
     */
    renameField(oldName: TColumnName<S, N>, newName: string): this;
    /**
     * Remove field by setting its visibility to false.
     * @param names the fields to remove
     * @example
     * .removeField('aFieldToRemove', 'anotherFieldToRemove');
     */
    removeField(...names: TColumnName<S, N>[]): this;
    /**
     * Add a new action on the collection.
     * @param name the name of the action
     * @param definition the definition of the action
     * @example
     * .addAction('is live', {
     *    scope: 'Single',
     *    execute: async (context, resultBuilder) => {
     *      return resultBuilder.success('Is live!');
     *    },
     *  })
     */
    addAction(name: string, definition: ActionDefinition<S, N>): this;
    /**
     * Create a new API chart
     * @param name name of the chart
     * @param definition definition of the chart
     * @example
     * .addChart('numCustomers', {
     *   type: 'Value',
     *   render: (context, resultBuilder) => {
     *     return resultBuilder.value(123);
     *   }
     * })
     */
    addChart(name: string, definition: CollectionChartDefinition<S, N>): this;
    /**
     * Add a new field on the collection.
     * @param name the name of the field
     * @param definition The definition of the field
     * @example
     * .addField('fullName', {
     *    columnType: 'String',
     *    dependencies: ['firstName', 'lastName'],
     *    getValues: (records) => records.map(record => \`${record.lastName} ${record.firstName}\`),
     * });
     */
    addField(name: string, definition: ComputedDefinition<S, N>): this;
    /**
     * Add a new validator to the edition form of a given field
     * @param name The name of the field
     * @param operator The validator that you wish to add
     * @param value A configuration value that the validator may need
     * @example
     * .addFieldValidation('firstName', 'LongerThan', 2);
     */
    addFieldValidation(name: TColumnName<S, N>, operator: Operator, value?: unknown): this;
    /**
     * Add a many to one relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * books.addManyToOneRelation('myAuthor', 'persons', { foreignKey: 'authorId' })
     */
    addManyToOneRelation<T extends TCollectionName<S>>(name: string, foreignCollection: T, options: {
        foreignKey: TColumnName<S, N>;
        foreignKeyTarget?: TColumnName<S, T>;
    }): this;
    /**
     * Add a one to many relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * persons.addOneToManyRelation('writtenBooks', 'books', { originKey: 'authorId' })
     */
    addOneToManyRelation<T extends TCollectionName<S>>(name: string, foreignCollection: T, options: {
        originKey: TColumnName<S, T>;
        originKeyTarget?: TColumnName<S, N>;
    }): this;
    /**
     * Add a one to one relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * persons.addOneToOneRelation('bestFriend', 'persons', { originKey: 'bestFriendId' })
     */
    addOneToOneRelation<T extends TCollectionName<S>>(name: string, foreignCollection: T, options: {
        originKey: TColumnName<S, T>;
        originKeyTarget?: TColumnName<S, N>;
    }): this;
    /**
     * Add a many to many relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param throughCollection name of the intermediary collection
     * @param options extra information about the relation
     * @example
     * dvds.addManyToManyRelation('rentalsOfThisDvd', 'rentals', 'dvdRentals', {
     *   originKey: 'dvdId',
     *   foreignKey: 'rentalId'
     * })
     */
    addManyToManyRelation<Foreign extends TCollectionName<S>, Through extends TCollectionName<S>>(name: string, foreignCollection: Foreign, throughCollection: Through, options: {
        originKey: TColumnName<S, Through>;
        foreignKey: TColumnName<S, Through>;
        originKeyTarget?: TColumnName<S, N>;
        foreignKeyTarget?: TColumnName<S, Foreign>;
    }): this;
    /**
     * Add a virtual collection into the related data of a record.
     *
     * @param name name of the relation
     * @param definition the definition of the new relation
     * @example
     * .addExternalRelation('states', {
     *   schema: { code: 'Number', name: 'String' },
     *   listRecords: ({ id }) => {
     *     return record.id == 34 ?
     *      [{ code: 'AL', name: 'Alabama' }, { code: 'AK', name: 'Alaska' }] :
     *      [{ code: 'AZ', name: 'Arizona' }, { code: 'TX', name: 'Texas' }];
     *   }
     * })
     */
    addExternalRelation(name: string, definition: OneToManyEmbeddedDefinition<S, N>): this;
    /**
     * Add a new segment on the collection.
     * @param name the name of the segment
     * @param definition a function used to generate a condition tree
     * or a condition tree
     * @example
     * .addSegment(
     *    'Wrote more than 2 books',
     *    { field: 'booksCount', operator: 'GreaterThan', value: 2 }
     * );
     */
    addSegment(name: string, definition: SegmentDefinition<S, N>): this;
    /**
     * Enable sorting on a specific field using emulation.
     * As for all the emulation method, the field sorting will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @example
     * .emulateFieldSorting('fullName');
     */
    emulateFieldSorting(name: TColumnName<S, N>): this;
    /**
     * Replace an implementation for the sorting.
     * The field sorting will be done by the datasource.
     * @param name the name of the field to enable sort
     * @param equivalentSort the sort equivalent
     * @example
     * .replaceFieldSorting(
     *   'fullName',
     *   [
     *     { field: 'firstName', ascending: true },
     *     { field: 'lastName',  ascending: true },
     *   ]
     * )
     */
    replaceFieldSorting(name: TColumnName<S, N>, equivalentSort: TSortClause<S, N>[]): this;
    /**
     * Enable filtering on a specific field using emulation.
     * As for all the emulation method, the field filtering will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @example
     * .emulateFieldFiltering('aField');
     */
    emulateFieldFiltering(name: TColumnName<S, N>): this;
    /**
     * Enable filtering on a specific field with a specific operator using emulation.
     * As for all the emulation method, the field filtering will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @param operator the operator to emulate
     * @example
     * .emulateFieldOperator('aField', 'In');
     */
    emulateFieldOperator(name: TColumnName<S, N>, operator: Operator): this;
    /**
     * Replace an implementation for a specific operator on a specific field.
     * The operator replacement will be done by the datasource.
     * @param name the name of the field to filter on
     * @param operator the operator to replace
     * @param replacer the proposed implementation
     * @example
     * .replaceFieldOperator('fullName', 'Contains', (value) => {
     *    return {
     *      aggregator: 'Or',
     *      conditions: [{
     *        field: 'firstName',
     *        operator: 'Contains',
     *        value
     *      }, {
     *        field: 'lastName',
     *        operator: 'Contains',
     *        value
     *      }]
     *    }
     * });
     */
    replaceFieldOperator<C extends TColumnName<S, N>>(name: C, operator: Operator, replacer: OperatorDefinition<S, N, C>): this;
    /**
     * Replace the write behavior of a field.
     * @param name the name of the field
     * @param definition the function or a value to represent the write behavior
     * @example
     * .replaceFieldWriting('fullName', fullName => {
     *   const [firstName, lastName] = fullName.split(' ');
     *   return { firstName, lastName };
     * });
     */
    replaceFieldWriting<C extends TColumnName<S, N>>(name: C, definition: WriteDefinition<S, N, C>): this;
    /**
     * Replace the behavior of the search bar
     * @param definition handler to describe the new behavior
     * @example
     * .replaceSearch(async (searchString) => {
     *   return { field: 'name', operator: 'Contains', value: searchString };
     * });
     */
    replaceSearch(definition: SearchDefinition<S, N>): this;
    addHook<P extends HookPosition, T extends HookType>(position: P, type: T, handler: HookHandler<HooksContext<S, N>[P][T]>): this;
    private pushRelation;
    private pushCustomization;
}
//# sourceMappingURL=collection-customizer.d.ts.map